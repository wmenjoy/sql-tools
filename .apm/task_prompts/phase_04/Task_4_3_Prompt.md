---
agent: Agent_Runtime_Interceptor
task_ref: Task 4.3
depends_on:
  - Task 2.13 (DefaultSqlSafetyValidator Assembly)
ad_hoc_delegation: false
---

# Task 4.3 - JDBC Druid Filter Implementation

## Objective
Implement Druid connection pool filter intercepting SQL at JDBC layer via FilterAdapter extension, validating PreparedStatement and Statement executions, extracting datasource context from ConnectionProxy, and integrating with Druid's monitoring and filter chain while maintaining minimal performance overhead.

## Context

**JDBC-Layer Interception**: Druid filter provides SQL interception at JDBC layer, catching SQL not passing through MyBatis/MyBatis-Plus layers (direct JDBC usage, JdbcTemplate, other ORM frameworks).

**FilterAdapter**: Druid's filter extension point for custom SQL processing. Intercepts PreparedStatement creation and Statement execution.

**Multi-Datasource Support**: ConnectionProxy provides datasource metadata enabling per-datasource violation tracking.

## Dependencies

### Input from Task 2.13 (Phase 2):
- DefaultSqlSafetyValidator (complete validation engine)
- SqlDeduplicationFilter (prevents redundant validation)
- ViolationStrategy (BLOCK/WARN/LOG)

### Independence:
- Task 4.3 is independent of Tasks 4.1 and 4.2
- Can coexist with MyBatis/MyBatis-Plus interceptors
- Provides coverage for non-MyBatis SQL execution

## Implementation Steps

### Step 1: Druid Filter TDD
**Goal**: Create FilterAdapter extension

**Tasks**:
1. Add Druid dependency to `sql-guard-jdbc/pom.xml`:
   ```xml
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>druid</artifactId>
       <version>1.2.20</version>
       <scope>provided</scope>
   </dependency>
   ```

2. Create `DruidSqlSafetyFilter` class:
   ```java
   public class DruidSqlSafetyFilter extends FilterAdapter {
       private final DefaultSqlSafetyValidator validator;
       private final ViolationStrategy strategy;

       @Override
       public PreparedStatementProxy createPreparedStatement(
           FilterChain chain, ConnectionProxy connection,
           String sql, int autoGeneratedKeys) throws SQLException {

           // Validate SQL at prepare time
           validateSql(sql, connection);

           return super.createPreparedStatement(
               chain, connection, sql, autoGeneratedKeys);
       }

       @Override
       protected void statement_executeQuery(
           StatementProxy statement, String sql) throws SQLException {

           // Validate SQL at execute time (Statement)
           validateSql(sql, statement.getConnectionProxy());

           super.statement_executeQuery(statement, sql);
       }

       @Override
       protected void statement_executeUpdate(
           StatementProxy statement, String sql) throws SQLException {

           validateSql(sql, statement.getConnectionProxy());

           super.statement_executeUpdate(statement, sql);
       }
   }
   ```

**Test Requirements**:
- `DruidSqlSafetyFilterTest.java` (10 tests):
  - testPreparedStatementInterception_shouldValidate()
  - testStatementExecuteQuery_shouldValidate()
  - testStatementExecuteUpdate_shouldValidate()
  - testDatasourceExtraction_shouldGetName()
  - testSqlTypeDetection_shouldIdentifyCommand()
  - testBLOCKStrategy_shouldThrowException()
  - testWARNStrategy_shouldLogAndContinue()
  - testLOGStrategy_shouldOnlyLog()
  - testValidSql_shouldProceed()
  - testFilterChain_shouldDelegate()

**Files to Create**:
- `sql-guard-jdbc/src/main/java/com/footstone/sqlguard/interceptor/druid/DruidSqlSafetyFilter.java`
- `sql-guard-jdbc/src/test/java/com/footstone/sqlguard/interceptor/druid/DruidSqlSafetyFilterTest.java`

---

### Step 2: validateSql Method Implementation
**Goal**: Extract SqlContext from JDBC execution

**Tasks**:
1. Implement `validateSql(String sql, ConnectionProxy connection)`:
   ```java
   private void validateSql(String sql, ConnectionProxy connection)
           throws SQLException {
       // Deduplication check
       if (!shouldValidate(sql)) {
           return;
       }

       // Detect SqlCommandType from SQL prefix
       SqlCommandType type = detectSqlType(sql);

       // Extract datasource name
       String datasourceName = extractDatasourceName(connection);

       // Build SqlContext
       SqlContext context = SqlContext.builder()
           .sql(sql)
           .type(type)
           .mapperId("jdbc-druid:" + datasourceName)
           .datasource(datasourceName)
           .build();

       // Validate
       ValidationResult result = validator.validate(context);

       // Handle violations
       if (!result.passed()) {
           handleViolation(result, datasourceName);
       }
   }
   ```

2. Implement `detectSqlType(String sql)`:
   ```java
   private SqlCommandType detectSqlType(String sql) {
       String upperSql = sql.trim().toUpperCase();

       if (upperSql.startsWith("SELECT")) {
           return SqlCommandType.SELECT;
       } else if (upperSql.startsWith("UPDATE")) {
           return SqlCommandType.UPDATE;
       } else if (upperSql.startsWith("DELETE")) {
           return SqlCommandType.DELETE;
       } else if (upperSql.startsWith("INSERT")) {
           return SqlCommandType.INSERT;
       } else {
           return SqlCommandType.UNKNOWN;
       }
   }
   ```

3. Implement `extractDatasourceName(ConnectionProxy connection)`:
   ```java
   private String extractDatasourceName(ConnectionProxy connection) {
       try {
           DataSourceProxy dataSource = connection.getDirectDataSource();
           String name = dataSource.getName();
           return name != null ? name : "default";
       } catch (Exception e) {
           logger.debug("Failed to extract datasource name", e);
           return "unknown";
       }
   }
   ```

**Test Requirements**:
- `ValidateSqlMethodTest.java` (12 tests):
  - testDetectSqlType_SELECT_shouldReturn()
  - testDetectSqlType_UPDATE_shouldReturn()
  - testDetectSqlType_DELETE_shouldReturn()
  - testDetectSqlType_INSERT_shouldReturn()
  - testDetectSqlType_caseInsensitive_shouldWork()
  - testDetectSqlType_withComments_shouldDetect()
  - testExtractDatasourceName_shouldGet()
  - testExtractDatasourceName_null_shouldReturnDefault()
  - testBuildSqlContext_shouldPopulateFields()
  - testMapperId_shouldIncludeDatasource()
  - testDeduplication_sameSQL_shouldSkip()
  - testHandleViolation_shouldFormatMessage()

**Files to Modify**:
- `DruidSqlSafetyFilter.java`

**Files to Create**:
- `sql-guard-jdbc/src/test/java/com/footstone/sqlguard/interceptor/druid/ValidateSqlMethodTest.java`

---

### Step 3: Filter Registration and Configuration
**Goal**: Register filter with DruidDataSource

**Tasks**:
1. Implement filter registration configuration:
   ```java
   public class DruidSqlSafetyFilterConfiguration {
       public static void registerFilter(
           DruidDataSource dataSource,
           DefaultSqlSafetyValidator validator,
           ViolationStrategy strategy) {

           DruidSqlSafetyFilter filter =
               new DruidSqlSafetyFilter(validator, strategy);

           // Set filter order (before StatFilter)
           filter.setOrder(1);

           // Add to proxy filters
           List<Filter> filters = dataSource.getProxyFilters();
           filters.add(filter);
           dataSource.setProxyFilters(filters);
       }
   }
   ```

2. Filter ordering strategy:
   - Druid default filters: ProtocolFilter=1, StatFilter=2
   - Safety filter order=1 ensures execution before StatFilter
   - This allows violations to be tracked in Druid statistics

3. Spring Boot integration:
   ```java
   @Bean
   @ConditionalOnClass(DruidDataSource.class)
   public DruidSqlSafetyFilter druidSqlSafetyFilter(
       DefaultSqlSafetyValidator validator) {
       return new DruidSqlSafetyFilter(validator, ViolationStrategy.WARN);
   }

   @Bean
   public BeanPostProcessor druidDataSourcePostProcessor(
       DruidSqlSafetyFilter filter) {
       return new BeanPostProcessor() {
           @Override
           public Object postProcessAfterInitialization(
               Object bean, String beanName) {
               if (bean instanceof DruidDataSource) {
                   DruidDataSource ds = (DruidDataSource) bean;
                   List<Filter> filters = ds.getProxyFilters();
                   filters.add(filter);
                   ds.setProxyFilters(filters);
               }
               return bean;
           }
       };
   }
   ```

**Test Requirements**:
- `FilterRegistrationTest.java` (10 tests):
  - testRegisterFilter_shouldAddToProxyFilters()
  - testFilterOrder_shouldBe1()
  - testFilterOrder_beforeStatFilter()
  - testMultipleDatasources_shouldRegisterEach()
  - testSpringBeanPostProcessor_shouldRegister()
  - testFilterExecution_shouldTriggerValidation()
  - testDruidStatistics_shouldIncludeViolations()
  - testFilterChain_shouldExecuteInOrder()
  - testRemoveFilter_shouldWork()
  - testDynamicRegistration_shouldWork()

**Files to Create**:
- `sql-guard-jdbc/src/main/java/com/footstone/sqlguard/interceptor/druid/DruidSqlSafetyFilterConfiguration.java`
- `sql-guard-jdbc/src/test/java/com/footstone/sqlguard/interceptor/druid/FilterRegistrationTest.java`

---

### Step 4: Druid Integration and Performance Testing
**Goal**: Full integration with DruidDataSource

**Tasks**:
1. Create integration test with H2:
   ```java
   @BeforeEach
   void setup() throws SQLException {
       // Create DruidDataSource
       dataSource = new DruidDataSource();
       dataSource.setUrl("jdbc:h2:mem:test");
       dataSource.setDriverClassName("org.h2.Driver");
       dataSource.setName("testDataSource");

       // Register filter
       DruidSqlSafetyFilterConfiguration.registerFilter(
           dataSource, validator, ViolationStrategy.BLOCK);

       // Initialize
       dataSource.init();
   }
   ```

2. Test PreparedStatement interception:
   ```java
   @Test
   void testPreparedStatement_dangerous_shouldBlock() {
       assertThrows(SQLException.class, () -> {
           try (Connection conn = dataSource.getConnection();
                PreparedStatement ps = conn.prepareStatement(
                    "UPDATE user SET name = ?")) {
               ps.setString(1, "test");
               ps.executeUpdate();
           }
       });
   }
   ```

3. Test Statement interception:
   ```java
   @Test
   void testStatement_dangerous_shouldBlock() {
       assertThrows(SQLException.class, () -> {
           try (Connection conn = dataSource.getConnection();
                Statement stmt = conn.createStatement()) {
               stmt.executeQuery("SELECT * FROM user");
           }
       });
   }
   ```

4. Test connection pooling:
   ```java
   @Test
   void testConnectionPool_shouldValidateAcrossConnections() {
       for (int i = 0; i < 10; i++) {
           try (Connection conn = dataSource.getConnection()) {
               // Each connection from pool should have filter applied
               assertThrows(SQLException.class, () -> {
                   Statement stmt = conn.createStatement();
                   stmt.executeQuery("SELECT * FROM user");
               });
           }
       }
   }
   ```

**Test Requirements**:
- `DruidIntegrationTest.java` (15 tests):
  - testSetup_druidDataSource_shouldInitialize()
  - testFilter_registered_shouldExistInProxyFilters()
  - testPreparedStatement_safe_shouldExecute()
  - testPreparedStatement_dangerous_shouldBlock()
  - testStatement_executeQuery_dangerous_shouldBlock()
  - testStatement_executeUpdate_dangerous_shouldBlock()
  - testConnectionPool_multipleConnections_shouldValidate()
  - testConnectionPool_borrowReturn_filterPersists()
  - testBatchExecution_shouldValidateEach()
  - testCallableStatement_shouldValidate()
  - testMultiThreaded_shouldBeThreadSafe()
  - testDatasourceName_shouldAppearInViolations()
  - testWARNStrategy_shouldExecuteButLog()
  - testLOGStrategy_shouldExecuteAndLog()
  - testDeduplication_shouldPreventDoubleCheck()

**Files to Create**:
- `sql-guard-jdbc/src/test/resources/schema.sql`
- `sql-guard-jdbc/src/test/java/com/footstone/sqlguard/interceptor/druid/DruidIntegrationTest.java`

---

### Step 5: Druid Plugin Compatibility and Performance
**Goal**: Test with Druid ecosystem plugins

**Tasks**:
1. Test with StatFilter (SQL statistics):
   ```java
   DruidDataSource dataSource = new DruidDataSource();
   dataSource.setFilters("stat");  // Enable StatFilter

   DruidSqlSafetyFilterConfiguration.registerFilter(
       dataSource, validator, strategy);

   // Verify both filters coexist
   // Verify violations appear in Druid statistics
   ```

2. Test with WallFilter (SQL firewall):
   ```java
   dataSource.setFilters("wall,stat");

   DruidSqlSafetyFilterConfiguration.registerFilter(
       dataSource, validator, strategy);

   // Verify all 3 filters work together
   ```

3. Test with encrypted datasource:
   ```java
   // ConfigFilter for password decryption
   dataSource.setFilters("config");
   dataSource.setConnectionProperties(
       "config.decrypt=true;config.decrypt.key=xxx");

   DruidSqlSafetyFilterConfiguration.registerFilter(
       dataSource, validator, strategy);
   ```

4. Performance testing:
   ```java
   // JMH micro-benchmark
   @Benchmark
   public void withoutFilter() throws SQLException {
       // Execute 10000 SQL statements without filter
   }

   @Benchmark
   public void withFilter() throws SQLException {
       // Execute 10000 SQL statements with filter
   }

   // Calculate overhead percentage
   // Target: <5%
   ```

**Test Requirements**:
- `DruidPluginCompatibilityTest.java` (12 tests):
  - testStatFilter_withSafety_shouldCoexist()
  - testStatFilter_violations_shouldAppearInStats()
  - testWallFilter_withSafety_shouldCoexist()
  - testWallFilter_sqlFirewall_andSafety_bothCheck()
  - testConfigFilter_encrypted_shouldWork()
  - testLogFilter_withSafety_shouldCoexist()
  - testMultipleFilters_executionOrder_correct()
  - testFilterChain_allExecute()
  - testDruidMonitor_violations_shouldShow()
  - testDruidWeb_statView_shouldDisplayViolations()
  - testRemoveFilter_dynamically_shouldWork()
  - testFilterDisabled_shouldNotIntercept()

- `DruidFilterPerformanceTest.java` (JMH benchmark):
  - Baseline: SQL execution without filter
  - With filter: SQL execution with DruidSqlSafetyFilter
  - Measure overhead percentage
  - Target: <5% overhead

**Files to Create**:
- `sql-guard-jdbc/src/test/java/com/footstone/sqlguard/interceptor/druid/DruidPluginCompatibilityTest.java`
- `sql-guard-jdbc/src/test/java/com/footstone/sqlguard/interceptor/druid/DruidFilterPerformanceTest.java`

---

## Expected Outcomes

### Functional Outcomes:
1. ✅ Druid FilterAdapter intercepts JDBC-layer SQL
2. ✅ PreparedStatement and Statement both validated
3. ✅ Datasource name extracted for multi-datasource tracking
4. ✅ SqlCommandType detected from SQL prefix
5. ✅ Compatible with Druid StatFilter, WallFilter, ConfigFilter
6. ✅ Filter ordering correct (before StatFilter)

### Test Outcomes:
- Total new tests: **59 tests** + JMH benchmark
- Integration tests with DruidDataSource
- Plugin compatibility verified
- Performance overhead measured

### Architecture Outcomes:
- ✅ JDBC-layer coverage (non-MyBatis SQL)
- ✅ Multi-datasource support
- ✅ Druid ecosystem integration
- ✅ Connection pool lifecycle handling

## Validation Criteria

### Must Pass Before Completion:
1. All 59 tests passing (100% pass rate)
2. Integration with DruidDataSource working
3. PreparedStatement interception working
4. Statement interception working
5. StatFilter compatibility verified
6. WallFilter compatibility verified
7. Performance benchmark <5% overhead

### Performance Benchmarks:
1. Filter overhead: <5%
2. PreparedStatement validation: <1ms
3. Statement validation: <1ms
4. Connection pool: no leaks

### Code Quality:
1. Google Java Style compliance
2. Comprehensive Javadoc
3. SLF4J logging

## Success Metrics

- ✅ 59 tests passing (100%)
- ✅ DruidDataSource integration working
- ✅ Filter ordering correct
- ✅ Plugin compatibility verified
- ✅ Performance target met (<5%)

## Timeline Estimate
- Step 1: 1 hour (FilterAdapter + 10 tests)
- Step 2: 1.5 hours (validateSql + 12 tests)
- Step 3: 1 hour (Registration + 10 tests)
- Step 4: 2 hours (Integration + 15 tests)
- Step 5: 2 hours (Compatibility + Performance + 12 tests + JMH)

**Total**: ~7.5 hours

## Definition of Done

- [ ] All 59 tests passing
- [ ] DruidDataSource integration working
- [ ] PreparedStatement interception working
- [ ] Statement interception working
- [ ] Filter ordering correct
- [ ] StatFilter compatibility verified
- [ ] WallFilter compatibility verified
- [ ] Performance <5% overhead
- [ ] Memory Log created
- [ ] Ready for HikariCP (Task 4.4)

---

**End of Task Assignment**

Druid filter provides JDBC-layer coverage for non-MyBatis SQL execution (JdbcTemplate, direct JDBC, other ORMs).
